# 시간 복잡도
> 알고리즘의 로직을 구현할 때 시간 복잡도를 고려한다는 것은 **입력 값의 변화에 따라 연산을 실행할 때 연산 횟수에 비해 시간이 얼마만큼 걸리는가**라는 말이다.

- 효율적인 알고리즘을 구현한다는 것은 입력 값이 커짐에 따라 증가하는 시간의 비율을 최소화한 알고리즘을 구성했다는 말이다.
- 시간 복잡도에 Big-O를 사용하여 나타낸다.

### Big-O 표기법

- 프로그램이 실행되는 과정에서 소요되는 최악의 상황까지 고려한다.
- 입력값의 변화에 따라 연산을 실행할 때 연산 횟수에 비해 시간이 얼마만큼 걸리는가를 표기하는 방법이다.

1. `O(1)`
    - **일정한 복잡도**라고 부르며 입력 값이 증가하더라도 시간이 늘지 않는다.
    - 입력 값의 크기와 상관없이 즉시 출력 값을 얻을 수 있다.
2. `O(n)`
    - **선형 복잡도**라고 부르며 입력값이 증가함에 따라 시간 또한 같은 비율로 증가한다.
    - 입력 값이 1일 때 1초의 시간이 걸리고 입력 값이 100배로 증가했을 때 1초의 100배인 100초가 걸리는 알고리즘의 시간복잡도는 O(n)이다.
3. `O(log n)`
    - 로그 복잡도라고 부르며 O(1) 다음으로 빠른 시간 복잡도이다.
    - 대표적인 예로 BST가 있다. BST에선 원하는 값을 탐색할 때 노드를 이동할 때마다 경우의 수가 절반으로 줄어든다.
    - up&down 게임일 경우 숫자를 제시할 때마다 경우의 수가 절반으로 줄어들어 최악의 경우에도 7번이면 원하는 숫자를 찾을 수 있다.
4. `O(n^2)`
    - 2차 복잡도라고 부르며 입력값이 증가함에 따라 시간이 n의 제곱수의 비율로 증가한다.
    - 입력 값이 1일 경우 1초가 걸리던 알고리즘에 5라는 값을 주었더니 25초가 걸리는 경우다.
5. `O(2^n)`
    - 기하급수적 복잡도라고 부르며 Big-O 중 가장 느린 시간 복잡도를 가진다.
    - 재귀로 구현하는 피보나치 수열은 O(2n)의 시간 복잡도를 가진 대표적인 알고리즘이다.

### 정리

1. O(1) : 스택 - push, pop
2. O(log n) : 이진 트리
3. O(n) : for 문
4. O(n log n) : 퀵 정렬, 병합 정렬, 힙 정렬
5. O(n^2) : 이중 for문, 삽입 정렬, 거품 정렬, 선택 정렬
6. O(2^n) : 피보나치 수열

### 참고

- [Big-O](https://noahlogs.tistory.com/27)
- [시간복잡도](https://hanamon.kr/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-time-complexity-%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84/)
